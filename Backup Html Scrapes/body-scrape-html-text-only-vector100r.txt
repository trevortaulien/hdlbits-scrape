



Vector100r - HDLBits























HDLBits




Menu






Problem Set

Browse Problem SetProblem Set StatsUser Rank List 

Simulation

Run a Simulation (Icarus Verilog) 

My Profile

Log in/outProfile SettingsMy Stats 

Help

Getting StartedAbout HDLBitsBugs and Suggestions 

01xz.net

01xz.net HomeHDLBits — Verilog practiceASMBits — Assembly language practiceCPUlator — Nios II, ARMv7, and MIPS simulator 






 Search








What links hereRelated changesSpecial pagesPrintable versionPermanent linkPage information 


Log in
















Vector100r
From HDLBits 



gates100Previous
Nextpopcount255

Given a 100-bit input vector [99:0], reverse its bit ordering.

Module Declaration
module top_module( 
    input [99:0] in,
    output [99:0] out
);

Hint...


A for loop (in a combinational always block or generate block) would be useful here. I would prefer a combinational always block in this case because module instantiations (which require generate blocks) aren't needed.


Write your solution here
[Load a previous submission]Load 



module top_module(   );

endmodule








Upload a source file... 
Or upload a file


Verilog source: 













Show solutionSolution
Loading...


 





always_if2
always_case
always_case2
always_casez
always_nolatches
conditional
reduction
gates100 · 

vector100r


 · popcount255
adder100i
bcdadd100
exams/m2014_q4h
exams/m2014_q4i
exams/m2014_q4e
exams/m2014_q4f
exams/m2014_q4g



gates100Previous
Nextpopcount255





Retrieved from "http://hdlbits.01xz.net/mw/index.php?title=Vector100r&oldid=1773"







Getting StartedGetting StartedOutput ZeroVerilog LanguageBasicsSimple wireFour wiresInverterAND gateNOR gateXNOR gateDeclaring wires7458 chipVectorsVectorsVectors in more detailVector part selectBitwise operatorsFour-input gatesVector concatenation operatorVector reversal 1Replication operatorMore replicationModules: HierarchyModulesConnecting ports by positionConnecting ports by nameThree modulesModules and vectorsAdder 1Adder 2Carry-select adderAdder-subtractorProceduresAlways blocks (combinational)Always blocks (clocked)If statementIf statement latchesCase statementPriority encoderPriority encoder with casezAvoiding latchesMore Verilog FeaturesConditional ternary operatorReduction operatorsReduction: Even wider gatesCombinational for-loop: Vector reversal 2Combinational for-loop: 255-bit population countGenerate for-loop: 100-bit binary adder 2Generate for-loop: 100-digit BCD adderCircuitsCombinational LogicBasic GatesWireGNDNORAnother gateTwo gatesMore logic gates7420 chipTruth tablesTwo-bit equalitySimple circuit ASimple circuit BCombine circuits A and BRing or vibrate?Thermostat3-bit population countGates and vectorsEven longer vectorsMultiplexers2-to-1 multiplexer2-to-1 bus multiplexer9-to-1 multiplexer256-to-1 multiplexer256-to-1 4-bit multiplexerArithmetic CircuitsHalf adderFull adder3-bit binary adderAdderSigned addition overflow100-bit binary adder4-digit BCD adderKarnaugh Map to Circuit3-variable4-variable4-variable4-variableMinimum SOP and POSKarnaugh mapKarnaugh mapK-map implemented with a multiplexerSequential LogicLatches and Flip-FlopsD flip-flopD flip-flopsDFF with resetDFF with reset valueDFF with asynchronous resetDFF with byte enableD LatchDFFDFFDFF+gateMux and DFFMux and DFFDFFs and gatesCreate circuit from truth tableDetect an edgeDetect both edgesEdge capture registerDual-edge triggered flip-flopCountersFour-bit binary counterDecade counterDecade counter againSlow decade counterCounter 1-12Counter 10004-digit decimal counter12-hour clockShift Registers4-bit shift registerLeft/right rotatorLeft/right arithmetic shift by 1 or 85-bit LFSR3-bit LFSR32-bit LFSRShift registerShift register3-input LUTMore CircuitsRule 90Rule 110Conway's Game of Life 16x16Finite State MachinesSimple FSM 1 (asynchronous reset)Simple FSM 1 (synchronous reset)Simple FSM 2 (asynchronous reset)Simple FSM 2 (synchronous reset)Simple state transitions 3Simple one-hot state transitions 3Simple FSM 3 (asynchronous reset)Simple FSM 3 (synchronous reset)Design a Moore FSMLemmings 1Lemmings 2Lemmings 3Lemmings 4One-hot FSMPS/2 packet parserPS/2 packet parser and datapathSerial receiverSerial receiver and datapathSerial receiver with parity checkingSequence recognitionQ8: Design a Mealy FSMQ5a: Serial two's complementer (Moore FSM)Q5b: Serial two's complementer (Mealy FSM)Q3a: FSMQ3b: FSMQ3c: FSM logicQ6b: FSM next-state logicQ6c: FSM one-hot next-state logicQ6: FSMQ2a: FSMQ2b: One-hot FSM equationsQ2a: FSMQ2b: Another FSMBuilding Larger CircuitsCounter with period 10004-bit shift register and down counterFSM: Sequence 1101 recognizerFSM: Enable shift registerFSM: The complete FSMThe complete timerFSM: One-hot logic equationsVerification: Reading SimulationsFinding bugs in codeMuxNANDMuxAdd/subCase statementBuild a circuit from a simulation waveformCombinational circuit 1Combinational circuit 2Combinational circuit 3Combinational circuit 4Combinational circuit 5Combinational circuit 6Sequential circuit 7Sequential circuit 8Sequential circuit 9Sequential circuit 10Verification: Writing TestbenchesClockTestbench1AND gateTestbench2T flip-flopCS450....
 





 This page was last modified on 8 October 2017, at 18:50.
Privacy policy
About HDLBits
Disclaimers




  








